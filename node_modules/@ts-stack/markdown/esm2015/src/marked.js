/**
 * @license
 *
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 *
 * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
 * https://github.com/ts-stack/markdown
 */
import { BlockLexer } from './block-lexer';
import { MarkedOptions, TokenType } from './interfaces';
import { Parser } from './parser';
export class Marked {
    /**
     * Merges the default options with options that will be set.
     *
     * @param options Hash of options.
     */
    static setOptions(options) {
        Object.assign(this.options, options);
        return this;
    }
    /**
     * Setting simple block rule.
     */
    static setBlockRule(regexp, renderer = () => '') {
        BlockLexer.simpleRules.push(regexp);
        this.simpleRenderers.push(renderer);
        return this;
    }
    /**
     * Accepts Markdown text and returns text in HTML format.
     *
     * @param src String of markdown source to be compiled.
     * @param options Hash of options. They replace, but do not merge with the default options.
     * If you want the merging, you can to do this via `Marked.setOptions()`.
     */
    static parse(src, options = this.options) {
        try {
            const { tokens, links } = this.callBlockLexer(src, options);
            return this.callParser(tokens, links, options);
        }
        catch (e) {
            return this.callMe(e);
        }
    }
    /**
     * Accepts Markdown text and returns object with text in HTML format,
     * tokens and links from `BlockLexer.parser()`.
     *
     * @param src String of markdown source to be compiled.
     * @param options Hash of options. They replace, but do not merge with the default options.
     * If you want the merging, you can to do this via `Marked.setOptions()`.
     */
    static debug(src, options = this.options) {
        const { tokens, links } = this.callBlockLexer(src, options);
        let origin = tokens.slice();
        const parser = new Parser(options);
        parser.simpleRenderers = this.simpleRenderers;
        const result = parser.debug(links, tokens);
        /**
         * Translates a token type into a readable form,
         * and moves `line` field to a first place in a token object.
         */
        origin = origin.map(token => {
            token.type = TokenType[token.type] || token.type;
            const line = token.line;
            delete token.line;
            if (line) {
                return Object.assign({ line }, token);
            }
            else {
                return token;
            }
        });
        return { tokens: origin, links, result };
    }
    static callBlockLexer(src = '', options) {
        if (typeof src != 'string') {
            throw new Error(`Expected that the 'src' parameter would have a 'string' type, got '${typeof src}'`);
        }
        // Preprocessing.
        src = src
            .replace(/\r\n|\r/g, '\n')
            .replace(/\t/g, '    ')
            .replace(/\u00a0/g, ' ')
            .replace(/\u2424/g, '\n')
            .replace(/^ +$/gm, '');
        return BlockLexer.lex(src, options, true);
    }
    static callParser(tokens, links, options) {
        if (this.simpleRenderers.length) {
            const parser = new Parser(options);
            parser.simpleRenderers = this.simpleRenderers;
            return parser.parse(links, tokens);
        }
        else {
            return Parser.parse(tokens, links, options);
        }
    }
    static callMe(err) {
        err.message += '\nPlease report this to https://github.com/ts-stack/markdown';
        if (this.options.silent) {
            return '<p>An error occured:</p><pre>' + this.options.escape(err.message + '', true) + '</pre>';
        }
        throw err;
    }
}
Marked.options = new MarkedOptions();
Marked.simpleRenderers = [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2VkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcHJvamVjdHMvbWFya2Rvd24vc3JjL21hcmtlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFxQyxhQUFhLEVBQXlCLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUNsSCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRWxDLE1BQU0sT0FBTyxNQUFNO0lBSWpCOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQXNCO1FBQ3RDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNyQyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxZQUFZLENBQUMsTUFBYyxFQUFFLFdBQTJCLEdBQUcsRUFBRSxDQUFDLEVBQUU7UUFDckUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFcEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFXLEVBQUUsVUFBeUIsSUFBSSxDQUFDLE9BQU87UUFDN0QsSUFBSTtZQUNGLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDNUQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDaEQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZ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RUFBRSxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUM7U0FDakc7UUFFRCxNQUFNLEdBQUcsQ0FBQztJQUNaLENBQUM7O0FBM0dNLGNBQU8sR0FBRyxJQUFJLGFBQWEsRUFBRSxDQUFDO0FBQ3BCLHNCQUFlLEdBQXFCLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIxLCDQmtC+0YHRgtGPINCi0YDQtdGC0Y/Qui4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90cy1zdGFjay9tYXJrZG93blxuICovXG5cbmltcG9ydCB7IEJsb2NrTGV4ZXIgfSBmcm9tICcuL2Jsb2NrLWxleGVyJztcbmltcG9ydCB7IERlYnVnUmV0dXJucywgTGV4ZXJSZXR1cm5zLCBMaW5rcywgTWFya2VkT3B0aW9ucywgU2ltcGxlUmVuZGVyZXIsIFRva2VuLCBUb2tlblR5cGUgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXInO1xuXG5leHBvcnQgY2xhc3MgTWFya2VkIHtcbiAgc3RhdGljIG9wdGlvbnMgPSBuZXcgTWFya2VkT3B0aW9ucygpO1xuICBwcm90ZWN0ZWQgc3RhdGljIHNpbXBsZVJlbmRlcmVyczogU2ltcGxlUmVuZGVyZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zLlxuICAgKi9cbiAgc3RhdGljIHNldE9wdGlvbnMob3B0aW9uczogTWFya2VkT3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0aW5nIHNpbXBsZSBibG9jayBydWxlLlxuICAgKi9cbiAgc3RhdGljIHNldEJsb2NrUnVsZShyZWdleHA6IFJlZ0V4cCwgcmVuZGVyZXI6IFNpbXBsZVJlbmRlcmVyID0gKCkgPT4gJycpIHtcbiAgICBCbG9ja0xleGVyLnNpbXBsZVJ1bGVzLnB1c2gocmVnZXhwKTtcbiAgICB0aGlzLnNpbXBsZVJlbmRlcmVycy5wdXNoKHJlbmRlcmVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgTWFya2Rvd24gdGV4dCBhbmQgcmV0dXJucyB0ZXh0IGluIEhUTUwgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gc3JjIFN0cmluZyBvZiBtYXJrZG93biBzb3VyY2UgdG8gYmUgY29tcGlsZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9ucy4gVGhleSByZXBsYWNlLCBidXQgZG8gbm90IG1lcmdlIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICogSWYgeW91IHdhbnQgdGhlIG1lcmdpbmcsIHlvdSBjYW4gdG8gZG8gdGhpcyB2aWEgYE1hcmtlZC5zZXRPcHRpb25zKClgLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlKHNyYzogc3RyaW5nLCBvcHRpb25zOiBNYXJrZWRPcHRpb25zID0gdGhpcy5vcHRpb25zKTogc3RyaW5nIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB0b2tlbnMsIGxpbmtzIH0gPSB0aGlzLmNhbGxCbG9ja0xleGVyKHNyYywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsUGFyc2VyKHRva2VucywgbGlua3MsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxNZShlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBNYXJrZG93biB0ZXh0IGFuZCByZXR1cm5zIG9iamVjdCB3aXRoIHRleHQgaW4gSFRNTCBmb3JtYXQsXG4gICAqIHRva2VucyBhbmQgbGlua3MgZnJvbSBgQmxvY2tMZXhlci5wYXJzZXIoKWAuXG4gICAqXG4gICAqIEBwYXJhbSBzcmMgU3RyaW5nIG9mIG1hcmtkb3duIHNvdXJjZSB0byBiZSBjb21waWxlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zLiBUaGV5IHJlcGxhY2UsIGJ1dCBkbyBub3QgbWVyZ2Ugd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgKiBJZiB5b3Ugd2FudCB0aGUgbWVyZ2luZywgeW91IGNhbiB0byBkbyB0aGlzIHZpYSBgTWFya2VkLnNldE9wdGlvbnMoKWAuXG4gICAqL1xuICBzdGF0aWMgZGVidWcoc3JjOiBzdHJpbmcsIG9wdGlvbnM6IE1hcmtlZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpOiBEZWJ1Z1JldHVybnMge1xuICAgIGNvbnN0IHsgdG9rZW5zLCBsaW5rcyB9ID0gdGhpcy5jYWxsQmxvY2tMZXhlcihzcmMsIG9wdGlvbnMpO1xuICAgIGxldCBvcmlnaW4gPSB0b2tlbnMuc2xpY2UoKTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHBhcnNlci5zaW1wbGVSZW5kZXJlcnMgPSB0aGlzLnNpbXBsZVJlbmRlcmVycztcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIuZGVidWcobGlua3MsIHRva2Vucyk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGEgdG9rZW4gdHlwZSBpbnRvIGEgcmVhZGFibGUgZm9ybSxcbiAgICAgKiBhbmQgbW92ZXMgYGxpbmVgIGZpZWxkIHRvIGEgZmlyc3QgcGxhY2UgaW4gYSB0b2tlbiBvYmplY3QuXG4gICAgICovXG4gICAgb3JpZ2luID0gb3JpZ2luLm1hcCh0b2tlbiA9PiB7XG4gICAgICB0b2tlbi50eXBlID0gKFRva2VuVHlwZSBhcyBhbnkpW3Rva2VuLnR5cGVdIHx8IHRva2VuLnR5cGU7XG5cbiAgICAgIGNvbnN0IGxpbmUgPSB0b2tlbi5saW5lO1xuICAgICAgZGVsZXRlIHRva2VuLmxpbmU7XG4gICAgICBpZiAobGluZSkge1xuICAgICAgICByZXR1cm4geyAuLi57IGxpbmUgfSwgLi4udG9rZW4gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7IHRva2Vuczogb3JpZ2luLCBsaW5rcywgcmVzdWx0IH07XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIGNhbGxCbG9ja0xleGVyKHNyYzogc3RyaW5nID0gJycsIG9wdGlvbnM/OiBNYXJrZWRPcHRpb25zKTogTGV4ZXJSZXR1cm5zIHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0aGF0IHRoZSAnc3JjJyBwYXJhbWV0ZXIgd291bGQgaGF2ZSBhICdzdHJpbmcnIHR5cGUsIGdvdCAnJHt0eXBlb2Ygc3JjfSdgKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwcm9jZXNzaW5nLlxuICAgIHNyYyA9IHNyY1xuICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpXG4gICAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAgIC5yZXBsYWNlKC9cXHUyNDI0L2csICdcXG4nKVxuICAgICAgLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcblxuICAgIHJldHVybiBCbG9ja0xleGVyLmxleChzcmMsIG9wdGlvbnMsIHRydWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN0YXRpYyBjYWxsUGFyc2VyKHRva2VuczogVG9rZW5bXSwgbGlua3M6IExpbmtzLCBvcHRpb25zPzogTWFya2VkT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuc2ltcGxlUmVuZGVyZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgIHBhcnNlci5zaW1wbGVSZW5kZXJlcnMgPSB0aGlzLnNpbXBsZVJlbmRlcmVycztcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2UobGlua3MsIHRva2Vucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQYXJzZXIucGFyc2UodG9rZW5zLCBsaW5rcywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHN0YXRpYyBjYWxsTWUoZXJyOiBFcnJvcikge1xuICAgIGVyci5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL3RzLXN0YWNrL21hcmtkb3duJztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+JyArIHRoaXMub3B0aW9ucy5lc2NhcGUoZXJyLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbiJdfQ==