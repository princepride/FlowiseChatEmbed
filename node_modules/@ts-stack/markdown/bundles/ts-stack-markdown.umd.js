(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('@ts-stack/markdown', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ts-stack'] = global['ts-stack'] || {}, global['ts-stack'].markdown = {})));
}(this, (function (exports) { 'use strict';

    /*
     * @license
     *
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    var ExtendRegexp = /** @class */ (function () {
        function ExtendRegexp(regex, flags) {
            if (flags === void 0) { flags = ''; }
            this.source = regex.source;
            this.flags = flags;
        }
        /**
         * Extend regular expression.
         *
         * @param groupName Regular expression for search a group name.
         * @param groupRegexp Regular expression of named group.
         */
        ExtendRegexp.prototype.setGroup = function (groupName, groupRegexp) {
            var newRegexp = typeof groupRegexp == 'string' ? groupRegexp : groupRegexp.source;
            newRegexp = newRegexp.replace(/(^|[^\[])\^/g, '$1');
            // Extend regexp.
            this.source = this.source.replace(groupName, newRegexp);
            return this;
        };
        /**
         * Returns a result of extending a regular expression.
         */
        ExtendRegexp.prototype.getRegexp = function () {
            return new RegExp(this.source, this.flags);
        };
        return ExtendRegexp;
    }());

    /**
     * @license
     *
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var replacements = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        // tslint:disable-next-line:quotemark
        "'": '&#39;',
    };
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    function escape(html, encode) {
        if (encode) {
            if (escapeTest.test(html)) {
                return html.replace(escapeReplace, function (ch) { return replacements[ch]; });
            }
        }
        else {
            if (escapeTestNoEncode.test(html)) {
                return html.replace(escapeReplaceNoEncode, function (ch) { return replacements[ch]; });
            }
        }
        return html;
    }
    function unescape(html) {
        // Explicitly match decimal, hex, and named HTML entities
        return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi, function (_, n) {
            n = n.toLowerCase();
            if (n === 'colon') {
                return ':';
            }
            if (n.charAt(0) === '#') {
                return n.charAt(1) === 'x'
                    ? String.fromCharCode(parseInt(n.substring(2), 16))
                    : String.fromCharCode(+n.substring(1));
            }
            return '';
        });
    }

    /**
     * @license
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    exports.TokenType = void 0;
    (function (TokenType) {
        TokenType[TokenType["space"] = 1] = "space";
        TokenType[TokenType["text"] = 2] = "text";
        TokenType[TokenType["paragraph"] = 3] = "paragraph";
        TokenType[TokenType["heading"] = 4] = "heading";
        TokenType[TokenType["listStart"] = 5] = "listStart";
        TokenType[TokenType["listEnd"] = 6] = "listEnd";
        TokenType[TokenType["looseItemStart"] = 7] = "looseItemStart";
        TokenType[TokenType["looseItemEnd"] = 8] = "looseItemEnd";
        TokenType[TokenType["listItemStart"] = 9] = "listItemStart";
        TokenType[TokenType["listItemEnd"] = 10] = "listItemEnd";
        TokenType[TokenType["blockquoteStart"] = 11] = "blockquoteStart";
        TokenType[TokenType["blockquoteEnd"] = 12] = "blockquoteEnd";
        TokenType[TokenType["code"] = 13] = "code";
        TokenType[TokenType["table"] = 14] = "table";
        TokenType[TokenType["html"] = 15] = "html";
        TokenType[TokenType["hr"] = 16] = "hr";
    })(exports.TokenType || (exports.TokenType = {}));
    var MarkedOptions = /** @class */ (function () {
        function MarkedOptions() {
            this.gfm = true;
            this.tables = true;
            this.breaks = false;
            this.pedantic = false;
            this.sanitize = false;
            this.mangle = true;
            this.smartLists = false;
            this.silent = false;
            this.langPrefix = 'lang-';
            this.smartypants = false;
            this.headerPrefix = '';
            /**
             * Self-close the tags for void elements (&lt;br/&gt;, &lt;img/&gt;, etc.)
             * with a "/" as required by XHTML.
             */
            this.xhtml = false;
            /**
             * The function that will be using to escape HTML entities.
             * By default using inner helper.
             */
            this.escape = escape;
            /**
             * The function that will be using to unescape HTML entities.
             * By default using inner helper.
             */
            this.unescape = unescape;
        }
        return MarkedOptions;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @license
     *
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    var Renderer = /** @class */ (function () {
        function Renderer(options) {
            this.options = options || Marked.options;
        }
        Renderer.prototype.code = function (code, lang, escaped, meta) {
            if (this.options.highlight) {
                var out = this.options.highlight(code, lang);
                if (out != null && out !== code) {
                    escaped = true;
                    code = out;
                }
            }
            var escapedCode = (escaped ? code : this.options.escape(code, true));
            if (!lang) {
                return "\n<pre><code>" + escapedCode + "\n</code></pre>\n";
            }
            var className = this.options.langPrefix + this.options.escape(lang, true);
            return "\n<pre><code class=\"" + className + "\">" + escapedCode + "\n</code></pre>\n";
        };
        Renderer.prototype.blockquote = function (quote) {
            return "<blockquote>\n" + quote + "</blockquote>\n";
        };
        Renderer.prototype.html = function (html) {
            return html;
        };
        Renderer.prototype.heading = function (text, level, raw) {
            var id = this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, '-');
            return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
        };
        Renderer.prototype.hr = function () {
            return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
        };
        Renderer.prototype.list = function (body, ordered) {
            var type = ordered ? 'ol' : 'ul';
            return "\n<" + type + ">\n" + body + "</" + type + ">\n";
        };
        Renderer.prototype.listitem = function (text) {
            return '<li>' + text + '</li>\n';
        };
        Renderer.prototype.paragraph = function (text) {
            return '<p>' + text + '</p>\n';
        };
        Renderer.prototype.table = function (header, body) {
            return "\n<table>\n<thead>\n" + header + "</thead>\n<tbody>\n" + body + "</tbody>\n</table>\n";
        };
        Renderer.prototype.tablerow = function (content) {
            return '<tr>\n' + content + '</tr>\n';
        };
        Renderer.prototype.tablecell = function (content, flags) {
            var type = flags.header ? 'th' : 'td';
            var tag = flags.align ? '<' + type + ' style="text-align:' + flags.align + '">' : '<' + type + '>';
            return tag + content + '</' + type + '>\n';
        };
        // *** Inline level renderer methods. ***
        Renderer.prototype.strong = function (text) {
            return '<strong>' + text + '</strong>';
        };
        Renderer.prototype.em = function (text) {
            return '<em>' + text + '</em>';
        };
        Renderer.prototype.codespan = function (text) {
            return '<code>' + text + '</code>';
        };
        Renderer.prototype.br = function () {
            return this.options.xhtml ? '<br/>' : '<br>';
        };
        Renderer.prototype.del = function (text) {
            return '<del>' + text + '</del>';
        };
        Renderer.prototype.link = function (href, title, text) {
            if (this.options.sanitize) {
                var prot = void 0;
                try {
                    prot = decodeURIComponent(this.options.unescape(href))
                        .replace(/[^\w:]/g, '')
                        .toLowerCase();
                }
                catch (e) {
                    return text;
                }
                if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
                    return text;
                }
            }
            var out = '<a href="' + href + '"';
            if (title) {
                out += ' title="' + title + '"';
            }
            out += '>' + text + '</a>';
            return out;
        };
        Renderer.prototype.image = function (href, title, text) {
            var out = '<img src="' + href + '" alt="' + text + '"';
            if (title) {
                out += ' title="' + title + '"';
            }
            out += this.options.xhtml ? '/>' : '>';
            return out;
        };
        Renderer.prototype.text = function (text) {
            return text;
        };
        return Renderer;
    }());

    /**
     * @license
     *
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    /**
     * Inline Lexer & Compiler.
     */
    var InlineLexer = /** @class */ (function () {
        function InlineLexer(staticThis, links, options, renderer) {
            if (options === void 0) { options = Marked.options; }
            this.staticThis = staticThis;
            this.links = links;
            this.options = options;
            this.renderer = renderer || this.options.renderer || new Renderer(this.options);
            if (!this.links) {
                throw new Error("InlineLexer requires 'links' parameter.");
            }
            this.setRules();
        }
        /**
         * Static Lexing/Compiling Method.
         */
        InlineLexer.output = function (src, links, options) {
            var inlineLexer = new this(this, links, options);
            return inlineLexer.output(src);
        };
        InlineLexer.getRulesBase = function () {
            if (this.rulesBase) {
                return this.rulesBase;
            }
            /**
             * Inline-Level Grammar.
             */
            var base = {
                escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
                autolink: /^<([^ <>]+(@|:\/)[^ <>]+)>/,
                tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^<'">])*?>/,
                link: /^!?\[(inside)\]\(href\)/,
                reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
                nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
                strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
                em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
                code: /^(`+)([\s\S]*?[^`])\1(?!`)/,
                br: /^ {2,}\n(?!\s*$)/,
                text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/,
                _inside: /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,
                _href: /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/,
            };
            base.link = new ExtendRegexp(base.link).setGroup('inside', base._inside).setGroup('href', base._href).getRegexp();
            base.reflink = new ExtendRegexp(base.reflink).setGroup('inside', base._inside).getRegexp();
            return (this.rulesBase = base);
        };
        InlineLexer.getRulesPedantic = function () {
            if (this.rulesPedantic) {
                return this.rulesPedantic;
            }
            return (this.rulesPedantic = Object.assign(Object.assign({}, this.getRulesBase()), {
                strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
            }));
        };
        InlineLexer.getRulesGfm = function () {
            if (this.rulesGfm) {
                return this.rulesGfm;
            }
            var base = this.getRulesBase();
            var escape = new ExtendRegexp(base.escape).setGroup('])', '~|])').getRegexp();
            var text = new ExtendRegexp(base.text).setGroup(']|', '~]|').setGroup('|', '|https?://|').getRegexp();
            return (this.rulesGfm = Object.assign(Object.assign({}, base), {
                escape: escape,
                url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
                del: /^~~(?=\S)([\s\S]*?\S)~~/,
                text: text,
            }));
        };
        InlineLexer.getRulesBreaks = function () {
            if (this.rulesBreaks) {
                return this.rulesBreaks;
            }
            var inline = this.getRulesGfm();
            var gfm = this.getRulesGfm();
            return (this.rulesBreaks = Object.assign(Object.assign({}, gfm), {
                br: new ExtendRegexp(inline.br).setGroup('{2,}', '*').getRegexp(),
                text: new ExtendRegexp(gfm.text).setGroup('{2,}', '*').getRegexp(),
            }));
        };
        InlineLexer.prototype.setRules = function () {
            if (this.options.gfm) {
                if (this.options.breaks) {
                    this.rules = this.staticThis.getRulesBreaks();
                }
                else {
                    this.rules = this.staticThis.getRulesGfm();
                }
            }
            else if (this.options.pedantic) {
                this.rules = this.staticThis.getRulesPedantic();
            }
            else {
                this.rules = this.staticThis.getRulesBase();
            }
            this.hasRulesGfm = this.rules.url !== undefined;
        };
        /**
         * Lexing/Compiling.
         */
        InlineLexer.prototype.output = function (nextPart) {
            nextPart = nextPart;
            var execArr;
            var out = '';
            while (nextPart) {
                // escape
                if ((execArr = this.rules.escape.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += execArr[1];
                    continue;
                }
                // autolink
                if ((execArr = this.rules.autolink.exec(nextPart))) {
                    var text = void 0;
                    var href = void 0;
                    nextPart = nextPart.substring(execArr[0].length);
                    if (execArr[2] === '@') {
                        text = this.options.escape(execArr[1].charAt(6) === ':' ? this.mangle(execArr[1].substring(7)) : this.mangle(execArr[1]));
                        href = this.mangle('mailto:') + text;
                    }
                    else {
                        text = this.options.escape(execArr[1]);
                        href = text;
                    }
                    out += this.renderer.link(href, null, text);
                    continue;
                }
                // url (gfm)
                if (!this.inLink && this.hasRulesGfm && (execArr = this.rules.url.exec(nextPart))) {
                    var text = void 0;
                    var href = void 0;
                    nextPart = nextPart.substring(execArr[0].length);
                    text = this.options.escape(execArr[1]);
                    href = text;
                    out += this.renderer.link(href, null, text);
                    continue;
                }
                // tag
                if ((execArr = this.rules.tag.exec(nextPart))) {
                    if (!this.inLink && /^<a /i.test(execArr[0])) {
                        this.inLink = true;
                    }
                    else if (this.inLink && /^<\/a>/i.test(execArr[0])) {
                        this.inLink = false;
                    }
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.options.sanitize
                        ? this.options.sanitizer
                            ? this.options.sanitizer(execArr[0])
                            : this.options.escape(execArr[0])
                        : execArr[0];
                    continue;
                }
                // link
                if ((execArr = this.rules.link.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.inLink = true;
                    out += this.outputLink(execArr, {
                        href: execArr[2],
                        title: execArr[3],
                    });
                    this.inLink = false;
                    continue;
                }
                // reflink, nolink
                if ((execArr = this.rules.reflink.exec(nextPart)) || (execArr = this.rules.nolink.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    var keyLink = (execArr[2] || execArr[1]).replace(/\s+/g, ' ');
                    var link = this.links[keyLink.toLowerCase()];
                    if (!link || !link.href) {
                        out += execArr[0].charAt(0);
                        nextPart = execArr[0].substring(1) + nextPart;
                        continue;
                    }
                    this.inLink = true;
                    out += this.outputLink(execArr, link);
                    this.inLink = false;
                    continue;
                }
                // strong
                if ((execArr = this.rules.strong.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.renderer.strong(this.output(execArr[2] || execArr[1]));
                    continue;
                }
                // em
                if ((execArr = this.rules.em.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.renderer.em(this.output(execArr[2] || execArr[1]));
                    continue;
                }
                // code
                if ((execArr = this.rules.code.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.renderer.codespan(this.options.escape(execArr[2].trim(), true));
                    continue;
                }
                // br
                if ((execArr = this.rules.br.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.renderer.br();
                    continue;
                }
                // del (gfm)
                if (this.hasRulesGfm && (execArr = this.rules.del.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.renderer.del(this.output(execArr[1]));
                    continue;
                }
                // text
                if ((execArr = this.rules.text.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    out += this.renderer.text(this.options.escape(this.smartypants(execArr[0])));
                    continue;
                }
                if (nextPart) {
                    throw new Error('Infinite loop on byte: ' + nextPart.charCodeAt(0));
                }
            }
            return out;
        };
        /**
         * Compile Link.
         */
        InlineLexer.prototype.outputLink = function (execArr, link) {
            var href = this.options.escape(link.href);
            var title = link.title ? this.options.escape(link.title) : null;
            return execArr[0].charAt(0) !== '!'
                ? this.renderer.link(href, title, this.output(execArr[1]))
                : this.renderer.image(href, title, this.options.escape(execArr[1]));
        };
        /**
         * Smartypants Transformations.
         */
        InlineLexer.prototype.smartypants = function (text) {
            if (!this.options.smartypants) {
                return text;
            }
            return (text
                // em-dashes
                .replace(/---/g, '\u2014')
                // en-dashes
                .replace(/--/g, '\u2013')
                // opening singles
                .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
                // closing singles & apostrophes
                .replace(/'/g, '\u2019')
                // opening doubles
                .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
                // closing doubles
                .replace(/"/g, '\u201d')
                // ellipses
                .replace(/\.{3}/g, '\u2026'));
        };
        /**
         * Mangle Links.
         */
        InlineLexer.prototype.mangle = function (text) {
            if (!this.options.mangle) {
                return text;
            }
            var out = '';
            var length = text.length;
            for (var i = 0; i < length; i++) {
                var str = void 0;
                if (Math.random() > 0.5) {
                    str = 'x' + text.charCodeAt(i).toString(16);
                }
                out += '&#' + str + ';';
            }
            return out;
        };
        return InlineLexer;
    }());
    InlineLexer.rulesBase = null;
    /**
     * Pedantic Inline Grammar.
     */
    InlineLexer.rulesPedantic = null;
    /**
     * GFM Inline Grammar
     */
    InlineLexer.rulesGfm = null;
    /**
     * GFM + Line Breaks Inline Grammar.
     */
    InlineLexer.rulesBreaks = null;

    /**
     * Parsing & Compiling.
     */
    var Parser = /** @class */ (function () {
        function Parser(options) {
            this.simpleRenderers = [];
            this.line = 0;
            this.tokens = [];
            this.token = null;
            this.options = options || Marked.options;
            this.renderer = this.options.renderer || new Renderer(this.options);
        }
        Parser.parse = function (tokens, links, options) {
            var parser = new this(options);
            return parser.parse(links, tokens);
        };
        Parser.prototype.parse = function (links, tokens) {
            this.inlineLexer = new InlineLexer(InlineLexer, links, this.options, this.renderer);
            this.tokens = tokens.reverse();
            var out = '';
            while (this.next()) {
                out += this.tok();
            }
            return out;
        };
        Parser.prototype.debug = function (links, tokens) {
            this.inlineLexer = new InlineLexer(InlineLexer, links, this.options, this.renderer);
            this.tokens = tokens.reverse();
            var out = '';
            while (this.next()) {
                var outToken = this.tok();
                this.token.line = this.line += outToken.split('\n').length - 1;
                out += outToken;
            }
            return out;
        };
        Parser.prototype.next = function () {
            return (this.token = this.tokens.pop());
        };
        Parser.prototype.getNextElement = function () {
            return this.tokens[this.tokens.length - 1];
        };
        Parser.prototype.parseText = function () {
            var body = this.token.text;
            var nextElement;
            while ((nextElement = this.getNextElement()) && nextElement.type == exports.TokenType.text) {
                body += '\n' + this.next().text;
            }
            return this.inlineLexer.output(body);
        };
        Parser.prototype.tok = function () {
            var e_1, _a;
            switch (this.token.type) {
                case exports.TokenType.space: {
                    return '';
                }
                case exports.TokenType.paragraph: {
                    return this.renderer.paragraph(this.inlineLexer.output(this.token.text));
                }
                case exports.TokenType.text: {
                    if (this.options.isNoP) {
                        return this.parseText();
                    }
                    else {
                        return this.renderer.paragraph(this.parseText());
                    }
                }
                case exports.TokenType.heading: {
                    return this.renderer.heading(this.inlineLexer.output(this.token.text), this.token.depth, this.token.text);
                }
                case exports.TokenType.listStart: {
                    var body = '';
                    var ordered = this.token.ordered;
                    while (this.next().type != exports.TokenType.listEnd) {
                        body += this.tok();
                    }
                    return this.renderer.list(body, ordered);
                }
                case exports.TokenType.listItemStart: {
                    var body = '';
                    while (this.next().type != exports.TokenType.listItemEnd) {
                        body += this.token.type == exports.TokenType.text ? this.parseText() : this.tok();
                    }
                    return this.renderer.listitem(body);
                }
                case exports.TokenType.looseItemStart: {
                    var body = '';
                    while (this.next().type != exports.TokenType.listItemEnd) {
                        body += this.tok();
                    }
                    return this.renderer.listitem(body);
                }
                case exports.TokenType.code: {
                    return this.renderer.code(this.token.text, this.token.lang, this.token.escaped, this.token.meta);
                }
                case exports.TokenType.table: {
                    var header = '';
                    var body = '';
                    var cell = void 0;
                    // header
                    cell = '';
                    for (var i = 0; i < this.token.header.length; i++) {
                        var flags = { header: true, align: this.token.align[i] };
                        var out = this.inlineLexer.output(this.token.header[i]);
                        cell += this.renderer.tablecell(out, flags);
                    }
                    header += this.renderer.tablerow(cell);
                    try {
                        for (var _b = __values(this.token.cells), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var row = _c.value;
                            cell = '';
                            for (var j = 0; j < row.length; j++) {
                                cell += this.renderer.tablecell(this.inlineLexer.output(row[j]), {
                                    header: false,
                                    align: this.token.align[j]
                                });
                            }
                            body += this.renderer.tablerow(cell);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return this.renderer.table(header, body);
                }
                case exports.TokenType.blockquoteStart: {
                    var body = '';
                    while (this.next().type != exports.TokenType.blockquoteEnd) {
                        body += this.tok();
                    }
                    return this.renderer.blockquote(body);
                }
                case exports.TokenType.hr: {
                    return this.renderer.hr();
                }
                case exports.TokenType.html: {
                    var html = !this.token.pre && !this.options.pedantic ? this.inlineLexer.output(this.token.text) : this.token.text;
                    return this.renderer.html(html);
                }
                default: {
                    if (this.simpleRenderers.length) {
                        for (var i = 0; i < this.simpleRenderers.length; i++) {
                            if (this.token.type == 'simpleRule' + (i + 1)) {
                                return this.simpleRenderers[i].call(this.renderer, this.token.execArr);
                            }
                        }
                    }
                    var errMsg = "Token with \"" + this.token.type + "\" type was not found.";
                    if (this.options.silent) {
                        console.log(errMsg);
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        };
        return Parser;
    }());

    /**
     * @license
     *
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    var Marked = /** @class */ (function () {
        function Marked() {
        }
        /**
         * Merges the default options with options that will be set.
         *
         * @param options Hash of options.
         */
        Marked.setOptions = function (options) {
            Object.assign(this.options, options);
            return this;
        };
        /**
         * Setting simple block rule.
         */
        Marked.setBlockRule = function (regexp, renderer) {
            if (renderer === void 0) { renderer = function () { return ''; }; }
            BlockLexer.simpleRules.push(regexp);
            this.simpleRenderers.push(renderer);
            return this;
        };
        /**
         * Accepts Markdown text and returns text in HTML format.
         *
         * @param src String of markdown source to be compiled.
         * @param options Hash of options. They replace, but do not merge with the default options.
         * If you want the merging, you can to do this via `Marked.setOptions()`.
         */
        Marked.parse = function (src, options) {
            if (options === void 0) { options = this.options; }
            try {
                var _a = this.callBlockLexer(src, options), tokens = _a.tokens, links = _a.links;
                return this.callParser(tokens, links, options);
            }
            catch (e) {
                return this.callMe(e);
            }
        };
        /**
         * Accepts Markdown text and returns object with text in HTML format,
         * tokens and links from `BlockLexer.parser()`.
         *
         * @param src String of markdown source to be compiled.
         * @param options Hash of options. They replace, but do not merge with the default options.
         * If you want the merging, you can to do this via `Marked.setOptions()`.
         */
        Marked.debug = function (src, options) {
            if (options === void 0) { options = this.options; }
            var _a = this.callBlockLexer(src, options), tokens = _a.tokens, links = _a.links;
            var origin = tokens.slice();
            var parser = new Parser(options);
            parser.simpleRenderers = this.simpleRenderers;
            var result = parser.debug(links, tokens);
            /**
             * Translates a token type into a readable form,
             * and moves `line` field to a first place in a token object.
             */
            origin = origin.map(function (token) {
                token.type = exports.TokenType[token.type] || token.type;
                var line = token.line;
                delete token.line;
                if (line) {
                    return Object.assign({ line: line }, token);
                }
                else {
                    return token;
                }
            });
            return { tokens: origin, links: links, result: result };
        };
        Marked.callBlockLexer = function (src, options) {
            if (src === void 0) { src = ''; }
            if (typeof src != 'string') {
                throw new Error("Expected that the 'src' parameter would have a 'string' type, got '" + typeof src + "'");
            }
            // Preprocessing.
            src = src
                .replace(/\r\n|\r/g, '\n')
                .replace(/\t/g, '    ')
                .replace(/\u00a0/g, ' ')
                .replace(/\u2424/g, '\n')
                .replace(/^ +$/gm, '');
            return BlockLexer.lex(src, options, true);
        };
        Marked.callParser = function (tokens, links, options) {
            if (this.simpleRenderers.length) {
                var parser = new Parser(options);
                parser.simpleRenderers = this.simpleRenderers;
                return parser.parse(links, tokens);
            }
            else {
                return Parser.parse(tokens, links, options);
            }
        };
        Marked.callMe = function (err) {
            err.message += '\nPlease report this to https://github.com/ts-stack/markdown';
            if (this.options.silent) {
                return '<p>An error occured:</p><pre>' + this.options.escape(err.message + '', true) + '</pre>';
            }
            throw err;
        };
        return Marked;
    }());
    Marked.options = new MarkedOptions();
    Marked.simpleRenderers = [];

    /**
     * @license
     *
     * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/chjj/marked
     *
     * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
     * https://github.com/ts-stack/markdown
     */
    var BlockLexer = /** @class */ (function () {
        function BlockLexer(staticThis, options) {
            this.staticThis = staticThis;
            this.links = {};
            this.tokens = [];
            this.options = options || Marked.options;
            this.setRules();
        }
        /**
         * Accepts Markdown text and returns object with tokens and links.
         *
         * @param src String of markdown source to be compiled.
         * @param options Hash of options.
         */
        BlockLexer.lex = function (src, options, top, isBlockQuote) {
            var lexer = new this(this, options);
            return lexer.getTokens(src, top, isBlockQuote);
        };
        BlockLexer.getRulesBase = function () {
            if (this.rulesBase) {
                return this.rulesBase;
            }
            var base = {
                newline: /^\n+/,
                code: /^( {4}[^\n]+\n*)+/,
                hr: /^( *[-*_]){3,} *(?:\n+|$)/,
                heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
                lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
                blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
                list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
                html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
                def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
                paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
                text: /^[^\n]+/,
                bullet: /(?:[*+-]|\d+\.)/,
                item: /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/,
            };
            base.item = new ExtendRegexp(base.item, 'gm').setGroup(/bull/g, base.bullet).getRegexp();
            base.list = new ExtendRegexp(base.list)
                .setGroup(/bull/g, base.bullet)
                .setGroup('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
                .setGroup('def', '\\n+(?=' + base.def.source + ')')
                .getRegexp();
            var tag = '(?!(?:' +
                'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' +
                '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' +
                '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
            base.html = new ExtendRegexp(base.html)
                .setGroup('comment', /<!--[\s\S]*?-->/)
                .setGroup('closed', /<(tag)[\s\S]+?<\/\1>/)
                .setGroup('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
                .setGroup(/tag/g, tag)
                .getRegexp();
            base.paragraph = new ExtendRegexp(base.paragraph)
                .setGroup('hr', base.hr)
                .setGroup('heading', base.heading)
                .setGroup('lheading', base.lheading)
                .setGroup('blockquote', base.blockquote)
                .setGroup('tag', '<' + tag)
                .setGroup('def', base.def)
                .getRegexp();
            return (this.rulesBase = base);
        };
        BlockLexer.getRulesGfm = function () {
            if (this.rulesGfm) {
                return this.rulesGfm;
            }
            var base = this.getRulesBase();
            var gfm = Object.assign(Object.assign({}, base), {
                fences: /^ *(`{3,}|~{3,})[ \.]*((\S+)? *[^\n]*)\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
                paragraph: /^/,
                heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/,
            });
            var group1 = gfm.fences.source.replace('\\1', '\\2');
            var group2 = base.list.source.replace('\\1', '\\3');
            gfm.paragraph = new ExtendRegexp(base.paragraph).setGroup('(?!', "(?!" + group1 + "|" + group2 + "|").getRegexp();
            return (this.rulesGfm = gfm);
        };
        BlockLexer.getRulesTable = function () {
            if (this.rulesTables) {
                return this.rulesTables;
            }
            return (this.rulesTables = Object.assign(Object.assign({}, this.getRulesGfm()), {
                nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
                table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/,
            }));
        };
        BlockLexer.prototype.setRules = function () {
            if (this.options.gfm) {
                if (this.options.tables) {
                    this.rules = this.staticThis.getRulesTable();
                }
                else {
                    this.rules = this.staticThis.getRulesGfm();
                }
            }
            else {
                this.rules = this.staticThis.getRulesBase();
            }
            this.hasRulesGfm = this.rules.fences !== undefined;
            this.hasRulesTables = this.rules.table !== undefined;
        };
        /**
         * Lexing.
         */
        BlockLexer.prototype.getTokens = function (src, top, isBlockQuote) {
            var nextPart = src;
            var execArr;
            mainLoop: while (nextPart) {
                // newline
                if ((execArr = this.rules.newline.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    if (execArr[0].length > 1) {
                        this.tokens.push({ type: exports.TokenType.space });
                    }
                }
                // code
                if ((execArr = this.rules.code.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    var code = execArr[0].replace(/^ {4}/gm, '');
                    this.tokens.push({
                        type: exports.TokenType.code,
                        text: !this.options.pedantic ? code.replace(/\n+$/, '') : code,
                    });
                    continue;
                }
                // fences code (gfm)
                if (this.hasRulesGfm && (execArr = this.rules.fences.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.tokens.push({
                        type: exports.TokenType.code,
                        meta: execArr[2],
                        lang: execArr[3],
                        text: execArr[4] || '',
                    });
                    continue;
                }
                // heading
                if ((execArr = this.rules.heading.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.tokens.push({
                        type: exports.TokenType.heading,
                        depth: execArr[1].length,
                        text: execArr[2],
                    });
                    continue;
                }
                // table no leading pipe (gfm)
                if (top && this.hasRulesTables && (execArr = this.rules.nptable.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    var item = {
                        type: exports.TokenType.table,
                        header: execArr[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
                        align: execArr[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                        cells: [],
                    };
                    for (var i = 0; i < item.align.length; i++) {
                        if (/^ *-+: *$/.test(item.align[i])) {
                            item.align[i] = 'right';
                        }
                        else if (/^ *:-+: *$/.test(item.align[i])) {
                            item.align[i] = 'center';
                        }
                        else if (/^ *:-+ *$/.test(item.align[i])) {
                            item.align[i] = 'left';
                        }
                        else {
                            item.align[i] = null;
                        }
                    }
                    var td = execArr[3].replace(/\n$/, '').split('\n');
                    for (var i = 0; i < td.length; i++) {
                        item.cells[i] = td[i].split(/ *\| */);
                    }
                    this.tokens.push(item);
                    continue;
                }
                // lheading
                if ((execArr = this.rules.lheading.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.tokens.push({
                        type: exports.TokenType.heading,
                        depth: execArr[2] === '=' ? 1 : 2,
                        text: execArr[1],
                    });
                    continue;
                }
                // hr
                if ((execArr = this.rules.hr.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.tokens.push({ type: exports.TokenType.hr });
                    continue;
                }
                // blockquote
                if ((execArr = this.rules.blockquote.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.tokens.push({ type: exports.TokenType.blockquoteStart });
                    var str = execArr[0].replace(/^ *> ?/gm, '');
                    // Pass `top` to keep the current
                    // "toplevel" state. This is exactly
                    // how markdown.pl works.
                    this.getTokens(str);
                    this.tokens.push({ type: exports.TokenType.blockquoteEnd });
                    continue;
                }
                // list
                if ((execArr = this.rules.list.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    var bull = execArr[2];
                    this.tokens.push({ type: exports.TokenType.listStart, ordered: bull.length > 1 });
                    // Get each top-level item.
                    var str = execArr[0].match(this.rules.item);
                    var length = str.length;
                    var next = false;
                    var space = void 0;
                    var blockBullet = void 0;
                    var loose = void 0;
                    for (var i = 0; i < length; i++) {
                        var item = str[i];
                        // Remove the list item's bullet so it is seen as the next token.
                        space = item.length;
                        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
                        // Outdent whatever the list item contains. Hacky.
                        if (item.indexOf('\n ') !== -1) {
                            space -= item.length;
                            item = !this.options.pedantic
                                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                                : item.replace(/^ {1,4}/gm, '');
                        }
                        // Determine whether the next list item belongs here.
                        // Backpedal if it does not belong in this list.
                        if (this.options.smartLists && i !== length - 1) {
                            blockBullet = this.staticThis.getRulesBase().bullet.exec(str[i + 1])[0];
                            if (bull !== blockBullet && !(bull.length > 1 && blockBullet.length > 1)) {
                                nextPart = str.slice(i + 1).join('\n') + nextPart;
                                i = length - 1;
                            }
                        }
                        // Determine whether item is loose or not.
                        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                        // for discount behavior.
                        loose = next || /\n\n(?!\s*$)/.test(item);
                        if (i !== length - 1) {
                            next = item.charAt(item.length - 1) === '\n';
                            if (!loose) {
                                loose = next;
                            }
                        }
                        this.tokens.push({ type: loose ? exports.TokenType.looseItemStart : exports.TokenType.listItemStart });
                        // Recurse.
                        this.getTokens(item, false, isBlockQuote);
                        this.tokens.push({ type: exports.TokenType.listItemEnd });
                    }
                    this.tokens.push({ type: exports.TokenType.listEnd });
                    continue;
                }
                // html
                if ((execArr = this.rules.html.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    var attr = execArr[1];
                    var isPre = attr === 'pre' || attr === 'script' || attr === 'style';
                    this.tokens.push({
                        type: this.options.sanitize ? exports.TokenType.paragraph : exports.TokenType.html,
                        pre: !this.options.sanitizer && isPre,
                        text: execArr[0],
                    });
                    continue;
                }
                // def
                if (top && (execArr = this.rules.def.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.links[execArr[1].toLowerCase()] = {
                        href: execArr[2],
                        title: execArr[3],
                    };
                    continue;
                }
                // table (gfm)
                if (top && this.hasRulesTables && (execArr = this.rules.table.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    var item = {
                        type: exports.TokenType.table,
                        header: execArr[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
                        align: execArr[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                        cells: [],
                    };
                    for (var i = 0; i < item.align.length; i++) {
                        if (/^ *-+: *$/.test(item.align[i])) {
                            item.align[i] = 'right';
                        }
                        else if (/^ *:-+: *$/.test(item.align[i])) {
                            item.align[i] = 'center';
                        }
                        else if (/^ *:-+ *$/.test(item.align[i])) {
                            item.align[i] = 'left';
                        }
                        else {
                            item.align[i] = null;
                        }
                    }
                    var td = execArr[3].replace(/(?: *\| *)?\n$/, '').split('\n');
                    for (var i = 0; i < td.length; i++) {
                        item.cells[i] = td[i].replace(/^ *\| *| *\| *$/g, '').split(/ *\| */);
                    }
                    this.tokens.push(item);
                    continue;
                }
                // simple rules
                if (this.staticThis.simpleRules.length) {
                    var simpleRules = this.staticThis.simpleRules;
                    for (var i = 0; i < simpleRules.length; i++) {
                        if ((execArr = simpleRules[i].exec(nextPart))) {
                            nextPart = nextPart.substring(execArr[0].length);
                            var type = 'simpleRule' + (i + 1);
                            this.tokens.push({ type: type, execArr: execArr });
                            continue mainLoop;
                        }
                    }
                }
                // top-level paragraph
                if (top && (execArr = this.rules.paragraph.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    if (execArr[1].slice(-1) === '\n') {
                        this.tokens.push({
                            type: exports.TokenType.paragraph,
                            text: execArr[1].slice(0, -1),
                        });
                    }
                    else {
                        this.tokens.push({
                            type: this.tokens.length > 0 ? exports.TokenType.paragraph : exports.TokenType.text,
                            text: execArr[1],
                        });
                    }
                    continue;
                }
                // text
                // Top-level should never reach here.
                if ((execArr = this.rules.text.exec(nextPart))) {
                    nextPart = nextPart.substring(execArr[0].length);
                    this.tokens.push({ type: exports.TokenType.text, text: execArr[0] });
                    continue;
                }
                if (nextPart) {
                    throw new Error('Infinite loop on byte: ' + nextPart.charCodeAt(0) + (", near text '" + nextPart.slice(0, 30) + "...'"));
                }
            }
            return { tokens: this.tokens, links: this.links };
        };
        return BlockLexer;
    }());
    BlockLexer.simpleRules = [];
    BlockLexer.rulesBase = null;
    /**
     * GFM Block Grammar.
     */
    BlockLexer.rulesGfm = null;
    /**
     * GFM + Tables Block Grammar.
     */
    BlockLexer.rulesTables = null;

    /**
     * Generated bundle index. Do not edit.
     */

    exports.BlockLexer = BlockLexer;
    exports.ExtendRegexp = ExtendRegexp;
    exports.InlineLexer = InlineLexer;
    exports.Marked = Marked;
    exports.MarkedOptions = MarkedOptions;
    exports.Parser = Parser;
    exports.Renderer = Renderer;
    exports.escape = escape;
    exports.unescape = unescape;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ts-stack-markdown.umd.js.map
